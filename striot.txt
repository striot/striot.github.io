-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package striot
@version 0.1.0.4

module Striot.FunctionalIoTtypes
data Event alpha
Event :: Maybe Timestamp -> Maybe alpha -> Event alpha
[time] :: Event alpha -> Maybe Timestamp
[value] :: Event alpha -> Maybe alpha
type Timestamp = UTCTime
type Stream alpha = [Event alpha]
dataEvent :: Event alpha -> Bool
timedEvent :: Event alpha -> Bool
instance GHC.Generics.Generic (Striot.FunctionalIoTtypes.Event alpha)
instance GHC.Read.Read alpha => GHC.Read.Read (Striot.FunctionalIoTtypes.Event alpha)
instance GHC.Show.Show alpha => GHC.Show.Show (Striot.FunctionalIoTtypes.Event alpha)
instance GHC.Classes.Ord alpha => GHC.Classes.Ord (Striot.FunctionalIoTtypes.Event alpha)
instance GHC.Classes.Eq alpha => GHC.Classes.Eq (Striot.FunctionalIoTtypes.Event alpha)
instance Data.Store.Impl.Store alpha => Data.Store.Impl.Store (Striot.FunctionalIoTtypes.Event alpha)

module Striot.FunctionalProcessing
streamFilter :: EventFilter alpha -> Stream alpha -> Stream alpha
streamMap :: EventMap alpha beta -> Stream alpha -> Stream beta
streamWindow :: WindowMaker alpha -> Stream alpha -> Stream [alpha]
streamWindowAggregate :: WindowMaker alpha -> WindowAggregator alpha beta -> Stream alpha -> Stream beta
streamMerge :: [Stream alpha] -> Stream alpha
streamJoin :: Stream alpha -> Stream beta -> Stream (alpha, beta)
streamJoinE :: WindowMaker alpha -> WindowMaker beta -> JoinFilter alpha beta -> JoinMap alpha beta gamma -> Stream alpha -> Stream beta -> Stream gamma
streamJoinW :: WindowMaker alpha -> WindowMaker beta -> ([alpha] -> [beta] -> gamma) -> Stream alpha -> Stream beta -> Stream gamma
streamFilterAcc :: (beta -> alpha -> beta) -> beta -> (alpha -> beta -> Bool) -> Stream alpha -> Stream alpha
streamScan :: (beta -> alpha -> beta) -> beta -> Stream alpha -> Stream beta
streamExpand :: Stream [alpha] -> Stream alpha
type WindowMaker alpha = Stream alpha -> [Stream alpha]
type WindowAggregator alpha beta = [alpha] -> beta
sliding :: Int -> WindowMaker alpha
slidingTime :: Int -> WindowMaker alpha
chop :: Int -> WindowMaker alpha
chopTime :: Int -> WindowMaker alpha
complete :: WindowMaker alpha
type EventFilter alpha = alpha -> Bool
type EventMap alpha beta = alpha -> beta
type JoinFilter alpha beta = alpha -> beta -> Bool
type JoinMap alpha beta gamma = alpha -> beta -> gamma
htf_Striot_FunctionalProcessing_thisModulesTests :: TestSuite
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Clock.Internal.UTCTime.UTCTime
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Striot.FunctionalIoTtypes.Event a)

module Striot.Nodes.Types
data Metrics
Metrics :: Gauge -> Counter -> Counter -> Gauge -> Counter -> Counter -> Metrics
[_ingressConn] :: Metrics -> Gauge
[_ingressBytes] :: Metrics -> Counter
[_ingressEvents] :: Metrics -> Counter
[_egressConn] :: Metrics -> Gauge
[_egressBytes] :: Metrics -> Counter
[_egressEvents] :: Metrics -> Counter
data NetConfig
NetConfig :: HostName -> ServiceName -> NetConfig
[_host] :: NetConfig -> HostName
[_port] :: NetConfig -> ServiceName
port :: Lens' NetConfig ServiceName
host :: Lens' NetConfig HostName
data TCPConfig
TCPConfig :: NetConfig -> TCPConfig
[_tcpConn] :: TCPConfig -> NetConfig
tcpConn :: Iso' TCPConfig NetConfig
data KafkaConfig
KafkaConfig :: NetConfig -> String -> String -> KafkaConfig
[_kafkaConn] :: KafkaConfig -> NetConfig
[_kafkaTopic] :: KafkaConfig -> String
[_kafkaConGroup] :: KafkaConfig -> String
kafkaTopic :: Lens' KafkaConfig String
kafkaConn :: Lens' KafkaConfig NetConfig
kafkaConGroup :: Lens' KafkaConfig String
data MQTTConfig
MQTTConfig :: NetConfig -> String -> MQTTConfig
[_mqttConn] :: MQTTConfig -> NetConfig
[_mqttTopic] :: MQTTConfig -> String
mqttTopic :: Lens' MQTTConfig String
mqttConn :: Lens' MQTTConfig NetConfig
data ConnectionConfig
ConnTCPConfig :: TCPConfig -> ConnectionConfig
ConnKafkaConfig :: KafkaConfig -> ConnectionConfig
ConnMQTTConfig :: MQTTConfig -> ConnectionConfig
data StriotConfig
StriotConfig :: String -> ConnectionConfig -> ConnectionConfig -> Int -> StriotConfig
[_nodeName] :: StriotConfig -> String
[_ingressConnConfig] :: StriotConfig -> ConnectionConfig
[_egressConnConfig] :: StriotConfig -> ConnectionConfig
[_chanSize] :: StriotConfig -> Int
class HasStriotConfig c_ayyq
striotConfig :: HasStriotConfig c_ayyq => Lens' c_ayyq StriotConfig
chanSize :: HasStriotConfig c_ayyq => Lens' c_ayyq Int
egressConnConfig :: HasStriotConfig c_ayyq => Lens' c_ayyq ConnectionConfig
ingressConnConfig :: HasStriotConfig c_ayyq => Lens' c_ayyq ConnectionConfig
nodeName :: HasStriotConfig c_ayyq => Lens' c_ayyq String
writeConf :: ConnectType -> ConnectionConfig -> [EnvVar]
readConf :: ConnectType -> Parser ConnectionConfig
nc :: String -> Parser NetConfig
newtype StriotApp a
StriotApp :: ReaderT StriotConfig IO a -> StriotApp a
[unApp] :: StriotApp a -> ReaderT StriotConfig IO a
data ConnectType
INGRESS :: ConnectType
EGRESS :: ConnectType
data ConnectProtocol
TCP :: ConnectProtocol
KAFKA :: ConnectProtocol
MQTT :: ConnectProtocol
instance GHC.Show.Show Striot.Nodes.Types.ConnectType
instance Control.Monad.IO.Class.MonadIO Striot.Nodes.Types.StriotApp
instance Control.Monad.Reader.Class.MonadReader Striot.Nodes.Types.StriotConfig Striot.Nodes.Types.StriotApp
instance GHC.Base.Monad Striot.Nodes.Types.StriotApp
instance GHC.Base.Applicative Striot.Nodes.Types.StriotApp
instance GHC.Base.Functor Striot.Nodes.Types.StriotApp
instance System.Envy.ToEnv Striot.Nodes.Types.StriotConfig
instance System.Envy.FromEnv Striot.Nodes.Types.StriotConfig
instance Striot.Nodes.Types.HasStriotConfig Striot.Nodes.Types.StriotConfig
instance GHC.Show.Show Striot.Nodes.Types.StriotConfig
instance GHC.Show.Show Striot.Nodes.Types.ConnectionConfig
instance GHC.Show.Show Striot.Nodes.Types.MQTTConfig
instance GHC.Show.Show Striot.Nodes.Types.KafkaConfig
instance GHC.Show.Show Striot.Nodes.Types.TCPConfig
instance GHC.Show.Show Striot.Nodes.Types.NetConfig

module Striot.Nodes.TCP
connectTCP :: Store alpha => String -> TCPConfig -> Metrics -> InChan (Event alpha) -> IO ()
sendStreamTCP :: Store alpha => String -> TCPConfig -> Metrics -> Stream alpha -> IO ()
processSocket :: Store alpha => String -> TCPConfig -> Metrics -> IO (Stream alpha)

module Striot.Nodes.MQTT
sendStreamMQTT :: Store alpha => String -> MQTTConfig -> Metrics -> Stream alpha -> IO ()
runMQTTSub :: Store alpha => String -> MQTTConfig -> Metrics -> InChan (Event alpha) -> IO ()

module Striot.Nodes.Kafka
sendStreamKafka :: Store alpha => String -> KafkaConfig -> Metrics -> Stream alpha -> IO ()
runKafkaConsumer :: Store alpha => String -> KafkaConfig -> Metrics -> InChan (Event alpha) -> IO ()

module Striot.Nodes
nodeSource :: (Store alpha, Store beta) => StriotConfig -> IO alpha -> (Stream alpha -> Stream beta) -> IO ()
nodeLink :: (Store alpha, Store beta) => StriotConfig -> (Stream alpha -> Stream beta) -> IO ()
nodeLink2 :: (Store alpha, Store beta, Store gamma) => (Stream alpha -> Stream beta -> Stream gamma) -> ServiceName -> ServiceName -> HostName -> ServiceName -> IO ()
nodeSink :: (Store alpha, Store beta) => StriotConfig -> (Stream alpha -> Stream beta) -> (Stream beta -> IO ()) -> IO ()
nodeSink2 :: (Store alpha, Store beta, Store gamma) => (Stream alpha -> Stream beta -> Stream gamma) -> (Stream gamma -> IO ()) -> ServiceName -> ServiceName -> IO ()

-- | a simple source-sink combined function for single-Node deployments.
nodeSimple :: IO a -> (Stream a -> Stream b) -> (Stream b -> IO ()) -> IO ()
defaultConfig :: String -> HostName -> ServiceName -> HostName -> ServiceName -> StriotConfig
defaultSource :: HostName -> ServiceName -> StriotConfig
defaultLink :: ServiceName -> HostName -> ServiceName -> StriotConfig
defaultSink :: ServiceName -> StriotConfig

-- | Convenience function for creating a pure Stream.
mkStream :: [a] -> Stream a

-- | A convenience function to extract a list of values from a Stream.
unStream :: Stream a -> [a]

module Striot.StreamGraph

-- | A graph representation of a stream-processing program.
type StreamGraph = Graph StreamVertex

-- | An enumeration of the possible stream operators within a
--   stream-processing program, as well as <a>Source</a> and <a>Sink</a> to
--   represent the ingress and egress points of programs.
data StreamOperator
Map :: StreamOperator
Filter :: Double -> StreamOperator
Expand :: StreamOperator
Window :: StreamOperator
Merge :: StreamOperator
Join :: StreamOperator
Scan :: StreamOperator
FilterAcc :: Double -> StreamOperator
Source :: Double -> StreamOperator
Sink :: StreamOperator

-- | The <a>StreamOperator</a> and associated information required to
--   encode a stream-processing program into a Graph. Each distinct
--   <a>StreamVertex</a> within a <a>StreamGraph</a> should have a unique
--   <a>vertexId</a> to ensure that they can be distinguished. For simple
--   path-style graphs, the IDs should be in ascending order.
data StreamVertex
StreamVertex :: Int -> StreamOperator -> [ExpQ] -> String -> String -> Double -> StreamVertex
[vertexId] :: StreamVertex -> Int
[operator] :: StreamVertex -> StreamOperator
[parameters] :: StreamVertex -> [ExpQ]
[intype] :: StreamVertex -> String
[outtype] :: StreamVertex -> String
[serviceTime] :: StreamVertex -> Double

-- | A collection of partitioned StreamGraphs
type PartitionedGraph = ([StreamGraph], StreamGraph)
deQ :: Q Exp -> Exp
isSource :: StreamOperator -> Bool
showParam :: Q Exp -> String
instance GHC.Classes.Eq Striot.StreamGraph.StreamOperator
instance GHC.Classes.Ord Striot.StreamGraph.StreamOperator
instance GHC.Show.Show Striot.StreamGraph.StreamOperator
instance GHC.Classes.Eq Striot.StreamGraph.StreamVertex
instance GHC.Show.Show Striot.StreamGraph.StreamVertex
instance GHC.Classes.Ord Striot.StreamGraph.StreamVertex
instance Test.QuickCheck.Arbitrary.Arbitrary Striot.StreamGraph.StreamVertex
instance Test.QuickCheck.Arbitrary.Arbitrary Striot.StreamGraph.StreamOperator

module Striot.LogicalOptimiser
applyRules :: Int -> StreamGraph -> [StreamGraph]
costModel :: StreamGraph -> Int

-- | Return an optimised version of the supplied StreamGraph, or the graph
--   itself if no better alternative is found.
optimise :: StreamGraph -> StreamGraph
firstMatch :: StreamGraph -> RewriteRule -> Maybe (StreamGraph -> StreamGraph)
filterMerge :: RewriteRule
mapFuse :: RewriteRule
htf_Striot_LogicalOptimiser_thisModulesTests :: TestSuite

module Striot.Jackson
data OperatorInfo
OperatorInfo :: Int -> Double -> Double -> Double -> Bool -> Double -> Double -> Double -> OperatorInfo
[opId] :: OperatorInfo -> Int
[arrRate] :: OperatorInfo -> Double
[serviceTime] :: OperatorInfo -> Double
[util] :: OperatorInfo -> Double
[stab] :: OperatorInfo -> Bool
[custInSys] :: OperatorInfo -> Double
[respTime] :: OperatorInfo -> Double
[queueTime] :: OperatorInfo -> Double
calcAll :: Array (Int, Int) Double -> Array Int Double -> Array Int Double -> [OperatorInfo]
arrivalRate :: Array (Int, Int) Double -> Array Int Double -> Double -> Array Int Double
arrivalRate' :: Array (Int, Int) Double -> Array Int Double -> Array Int Double

-- | Calculate the P propagation array for a StreamGraph based on its
--   filter selectivities.
derivePropagationArray :: StreamGraph -> Array (Int, Int) Double

-- | derive an Array of service times from a StreamGraph
deriveServiceTimes :: StreamGraph -> Array Int Double

-- | calculate an array of external input arrival probabilities
deriveInputsArray :: StreamGraph -> Double -> Array Int Double
calcAllSg :: StreamGraph -> [OperatorInfo]
taxiQ1Array :: Array (Int, Int) Double
taxiQ1Inputs :: Array Int Double
taxiQ1meanServiceTimes :: Array Int Double
taxiQ1arrivalRates :: Array Int Double
taxiQ1utilisation :: Array Int Double
taxiQ1Calc :: [OperatorInfo]
htf_Striot_Jackson_thisModulesTests :: TestSuite
instance GHC.Classes.Eq Striot.Jackson.OperatorInfo
instance GHC.Show.Show Striot.Jackson.OperatorInfo

module Striot.CompileIoT
createPartitions :: StreamGraph -> PartitionMap -> PartitionedGraph

-- | Partitions the supplied <a>StreamGraph</a> according to the supplied
--   <a>PartitionMap</a> and options specified within the supplied
--   <a>GenerateOpts</a> and returns a list of the sub-graphs converted
--   into source code and encoded as <a>String</a>s.
generateCode :: StreamGraph -> PartitionMap -> GenerateOpts -> [String]
data GenerateOpts
GenerateOpts :: [String] -> [String] -> Maybe String -> Bool -> GenerateOpts
[imports] :: GenerateOpts -> [String]
[packages] :: GenerateOpts -> [String]
[preSource] :: GenerateOpts -> Maybe String
[rewrite] :: GenerateOpts -> Bool
defaultOpts :: GenerateOpts

-- | The user's desired partitioning of the input Graph. Each element in
--   the outer-most list corresponds to a distinct partition. The
--   inner-lists are the IDs of Operators to include in that partition.
type PartitionMap = [[Int]]
writePart :: GenerateOpts -> (Int, String) -> IO ()
genDockerfile :: Bool -> GenerateOpts -> [Char]

-- | Partitions the supplied <a>StreamGraph</a> according to the supplied
--   <a>PartitionMap</a>; invokes <a>generateCode</a> for each derived
--   sub-graph; writes out the resulting source code to individual source
--   code files, one per node.
partitionGraph :: StreamGraph -> PartitionMap -> GenerateOpts -> IO ()

-- | Convenience function for specifying a simple path-style of stream
--   processing program, with no merge or join operations. The list of
--   tuples are converted into a series of connected Stream Vertices in a
--   Graph. The tuple arguments are the relevant <a>StreamOperator</a> for
--   the node; the parameters and the *output* type. The other parameters
--   to <a>StreamVertex</a> are inferred from the neighbouring tuples.
--   Unique and ascending <a>vertexId</a> values are assigned.
simpleStream :: [(StreamOperator, [ExpQ], String, Double)] -> Graph StreamVertex

-- | write out all rewritten versions of the input StreamGraph, along with
--   some of the necessary supporting code. TODO: rename this to something
--   more intuitive
optimiseWriteOutAll :: FilePath -> [Partition] -> StreamGraph -> IO ()

-- | Return an optimised version of the supplied StreamGraph, or the graph
--   itself if no better alternative is found.
optimise :: StreamGraph -> StreamGraph
generateCodeFromStreamGraph :: GenerateOpts -> [(Integer, StreamGraph)] -> StreamGraph -> (Integer, StreamGraph) -> String
nodeFn :: [(Integer, StreamGraph)] -> StreamGraph -> Integer -> StreamGraph -> GenerateOpts -> [Char]
nodeType :: StreamGraph -> NodeType
generateNodeSrc :: Integer -> [Integer] -> GenerateOpts -> [(Integer, StreamGraph)] -> String
connectNodeId :: StreamGraph -> [(Integer, StreamGraph)] -> StreamGraph -> [Integer]

-- | derive all optimisations of the supplied StreamGraph, calculate all
--   Jackson stuff from that
allOptimisations :: StreamGraph -> [(StreamGraph, [OperatorInfo])]
htf_Striot_CompileIoT_thisModulesTests :: TestSuite
instance GHC.Show.Show Striot.CompileIoT.NodeType

module Striot.VizGraph
streamGraphToDot :: StreamGraph -> String

-- | display a graph using GraphViz and "display" from ImageMagick
displayGraph :: StreamGraph -> IO ()

-- | display a graph inline in the Kitty terminal emulator
displayGraphKitty :: StreamGraph -> IO ()

-- | display a debug graph using GraphViz and ImageMagick
displayGraphDebug :: StreamGraph -> IO ()
htf_Striot_VizGraph_thisModulesTests :: TestSuite
